% Team Note Sample Template
% These codes should be guaranteed, fast enough, short and easy to type.

\documentclass[landscape, 10pt, a4paper, oneside, twocolumn]{extarticle}
\usepackage{kotex}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{import}

\usepackage{teamnote}

\teamnote{Kyunghee University}{(교내)우승후보}{overnap}

\ShowUsage
\ShowComplexity
\HideAuthor

\begin{document}

\maketitlepage

% Make Pagebreak if you want.
% \pagebreak 


\section{Data Structures For Range Query}

\Algorithm
{Segment Tree w/ Lazy Propagation}
{\texttt{update(1, 0, n-1, l, r, v)}}
{$\mathcal{O}(\log{N})$}
{cpp}
{source/LazyPropagation.cpp}
{overnap}

\Algorithm
{Sparse Table}
{RMQ l r: \texttt{min(lift[l][len], lift[r-(1<<len)+1][len])}}
{$\mathcal{O}(N)-\mathcal{O}(1)$}
{cpp}
{source/SparseTable.cpp}
{overnap}

\Algorithm
{Merge Sort Tree}
{}
{$\mathcal{O}(N\log{N})-\mathcal{O}(\log^2{N})$}
{cpp}
{source/MergeSortTree.cpp}
{overnap}

\Algorithm
{Binray Search In Segment Tree}
{}
{$\mathcal{O}(\log{N})$}
{cpp}
{source/BinarySearchInSeg.cpp}
{overnap}

\Algorithm
{Persistence Segment Tree}
{}
{$\mathcal{O}(\log^2{N})$}
{cpp}
{source/PersistenceSegmentTree.cpp}
{overnap}

\section{Graph}

\Algorithm
{BipartiteMatching}
{Run dfs for all left nodes. The count of return value true equal to count of max possible matches.}
{$\mathcal{O}(VE)$}
{cpp}
{source/BipartiteMatching.cpp}
{sendol}

\Algorithm
{Max Flow}
{}
{$\mathcal{O}(VE^2)$}
{cpp}
{source/EdmondsKarp.cpp}
{sendol}

\Algorithm
{Min Cost Max Flow}
{}
{$\mathcal{O}(VE^2)$}
{cpp}
{source/EdmondsKarpMCMF.cpp}
{sendol}

\Algorithm
{Strongly Connected Component}
{}
{$\mathcal{O}(N)$}
{cpp}
{source/StronglyConnectedComponent.cpp}
{overnap}

\Algorithm
{Biconnected Component}
{}
{$\mathcal{O}(N)$}
{cpp}
{source/BiconnectedComponent.cpp}
{overnap}

\Algorithm
{Lowest Common Ancestor}
{Query with the sparse table}
{$\mathcal{O}(N\log{N})-\mathcal{O}(\log{N})$}
{cpp}
{source/LowestCommonAncestor.cpp}
{overnap}

\Algorithm
{Heavy-Light Decomposition}
{Query with the ETT number and it's root node}
{$\mathcal{O}(N)-\mathcal{O}(\log{N})$}
{cpp}
{source/HeavyLightDecomposition.cpp}
{overnap}


\section{Geometry}

\Algorithm
{Counter Clockwise}
{It returns $\{-1, 0, 1\}$ - the ccw of $b-a$ and $c-b$}
{$\mathcal{O}(1)$}
{cpp}
{source/CounterClockwise.cpp}
{overnap}

\Algorithm
{Line intersection}
{Check the intersection of $(x_1, x_2)$ and $(y_1, y_2)$. It requires an additional condition when they are parallel}
{$\mathcal{O}(1)$}
{cpp}
{source/LineIntersection.cpp}
{overnap}

\Algorithm
{Graham Scan}
{}
{$\mathcal{O}(N\log{N})$}
{cpp}
{source/GrahamScan.cpp}
{overnap}

\Algorithm
{Monotone Chain}
{Get the upper and lower hull of the convex hull}
{$\mathcal{O}(N\log{N})$}
{cpp}
{source/MonotoneChain.cpp}
{overnap}

\Algorithm
{Rotating Calipers}
{Get the maximum distance of the convex hull}
{$\mathcal{O}(N)$}
{cpp}
{source/RotatingCalipers.cpp}
{overnap}


\section{Fast Fourier Transform}

\Algorithm
{Fast Fourier Transform}
{FFT and multiply polynomials}
{$\mathcal{O}(N\log{N})$}
{cpp}
{source/FastFourierTransform.cpp}
{overnap}

\Algorithm
{Number Theoretic Transform}
{FFT with integer - to get better accuracy}
{$\mathcal{O}(N\log{N})$}
{cpp}
{source/NumberTheoreticTransform.cpp}
{overnap}

\Algorithm
{Fast Walsh Hadamard Transform}
{XOR convolution}
{$\mathcal{O}(N\log{N})$}
{cpp}
{source/FastWalshHadamardTransform.cpp}
{overnap}


\section{String}

\Algorithm
{Knuth-Moris-Pratt}
{}
{$\mathcal{O}(N)$}
{cpp}
{source/KnuthMorisPratt.cpp}
{overnap}

\Algorithm
{Rabin-Karp}
{The Rabin fingerprint for const-length hashing}
{$\mathcal{O}(N)$}
{cpp}
{source/RabinKarp.cpp}
{overnap}

\Algorithm
{Manacher}
{Longest radius of palindrome substring}
{$\mathcal{O}(N)$}
{cpp}
{source/Manacher.cpp}
{overnap}

\Algorithm
{Suffix Array and LCP Array}
{}
{$\mathcal{O}(N\log{N})-\mathcal{O}(N)$}
{cpp}
{source/SuffixArrayLCPArray.cpp}
{overnap}

\Algorithm
{Aho-Corasick}
{}
{$\mathcal{O}(N+\sum{M})$}
{cpp}
{source/AhoCorasick.cpp}
{overnap}


\section{Offline Query}

\Algorithm
{Mo's}
{sort by $(L\sqrt{L}, R)$}
{$\mathcal{O}(Q\log{Q}+N\sqrt{N})$}
{cpp}
{source/Mos.cpp}
{overnap}

\Algorithm
{Parallel Binary Search}
{}
{$\mathcal{O}(N\log{N})$}
{cpp}
{source/ParallelBinarySearch.cpp}
{overnap}


\section{DP Optimization}

\Algorithm{Convex Hull Optimization w/ Stack}{}{}{}{}{}

\Algorithm{Convex Hull Optimization w/ Li-Chao Tree}{}{}{}{}{}

\Algorithm{Knuth Optimization}{}{}{}{}{}

\Algorithm{Slope Trick}{}{}{}{}{}


\section{Number Theory}

\Algorithm
{Modular Operator}
{For Fermat's little theorem and Pollard rho}
{$\mathcal{O}(N)-\mathcal{O}(1)$}
{cpp}
{source/ModularOperator.cpp}
{overnap}

\Algorithm
{Modular Inverse in $\mathcal{O}(N)$}
{Get inverse of factorial}
{$\mathcal{O}(N)-\mathcal{O}(1)$}
{cpp}
{source/ModularInverse.cpp}
{overnap}

\Algorithm
{Extended Euclidean}
{get a and b as arguments and return the solution $(x, y)$ of equation $ax + by = \gcd(a, b)$.}
{$\mathcal{O}(\log{a} + \log{b})$}
{cpp}
{source/ExtendedEuclidean.cpp}
{sendol}

\Algorithm
{Miller-Rabin}
{Fast prime test for big integers}
{$\mathcal{O}(k\log{N})$}
{cpp}
{source/MillerRabin.cpp}
{overnap}

\Algorithm
{Chinese Remainder Theorem}
{Solution for the system of linear congruence}
{$\mathcal{O}(\log{N})$}
{cpp}
{source/ChineseRemainderTheorem.cpp}
{overnap}

\Algorithm
{Pollard Rho}
{Factoring large numbers fast}
{$\mathcal{O}(N^{1/4})$}
{cpp}
{source/PollardRho.cpp}
{overnap}


\section{ETC}

\Algorithm
{Ternary Search}
{}
{$\mathcal{O}(\log{N})$}
{cpp}
{source/TernarySearch.cpp}
{overnap}

\section{Data Structure}

\Algorithm
{Randomized Meldable Heap}
{Min-heap \texttt{H} is declared as \texttt{Heap<T> H}. You can use \texttt{push}, \texttt{size}, \texttt{empty}, \texttt{top}, \texttt{pop} as \texttt{std::priority\_queue}. Use \texttt{H.meld(G)} to meld contents from \texttt{G} to \texttt{H}. }
{$\mathcal{O}(log n)$}
{cpp}{source/MeldableHeap.cpp}
{hyea}

\Algorithm
{Splay Tree w/ Rotate}
{}
{}
{}
{}
{}

\Algorithm
{Useful Stuff}
{}
{}
{}
{}
{}

% ref: https://github.com/green5555/Teamnote-archive
\begin{itemize}
    \setlength\itemsep{0.1em}

\item Catalan Number\\
1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012,742900\\
$C_n = binomial(n * 2, n) / (n + 1);$\\
- 길이가 2n인 올바른 괄호 수식의 수\\
- n + 1개의 리프를 가진 풀 바이너리 트리의 수\\
- n + 2각형을 n개의 삼각형으로 나누는 방법의 수

\item Burnside’s Lemma\\
경우의 수를 세는데, 특정 transform operation(회전, 반사, ..) 해서 같은 경우들은 하나로 친다. 전체 경우의 수는? 각 operation마다 이 operation을 했을 때 변하지 않는 경우의 수를 센다 (단, “아무것도 하지 않는다” 라는 operation도 있어야 함!) 전체 경우의 수를 더한 후, operation의 수로 나눈다. (답이 맞다면 항상 나누어 떨어져야 한다)

\item 알고리즘 게임\\
- Nim Game의 해법 : 각 더미의 돌의 개수를 모두 XOR했을 때 0 이 아니면 첫번째, 0 이면 두번째 플레이어가 승리.\\
- Grundy Number : 어떤 상황의 Grundy Number는, 가능한 다음 상황들의 Grundy Number를 모두 모은 다음, 그 집합에 포함 되지 않는 가장 작은 수가 현재 state의 Grundy Number가 된다. 만약 다음 state가 독립된 여러개의 state들로 나뉠 경우, 각각의 state의 Grundy Number의 XOR 합을 생각한다.\\
- Subtraction Game : 한 번에 k 개까지의 돌만 가져갈 수 있는 경우, 각 더미의 돌의 개수를 k + 1로 나눈 나머지를 XOR 합하여 판단한다.\\
- Index-k Nim : 한 번에 최대 k개의 더미를 골라 각각의 더미에서 아무렇게나 돌을 제거할 수 있을 때, 각 binary digit에 대하여 합을 k + 1로 나눈 나머지를 계산한다. 만약 이 나머지가 모든 digit에 대하여 0이라면 두번째, 하나라도 0이 아니라면 첫번째 플레이어가 승리.

\item Pick’s Theorem\\
격자점으로 구성된 simple polygon이 주어짐. I 는 polygon 내부의 격자점 수, B 는 polygon 선분 위 격자점 수, A는 polygon의 넓이라고 할 때, 다음과 같은 식이 성립한다. $A=I+B/2-1$

\item 가장 가까운 두 점 : 분할정복으로 가까운 6개의 점만 확인

\item 홀의 결혼 정리 : 이분그래프(L-R)에서, 모든 L을 매칭하는 필요충분 조건 = L에서 임의의 부분집합 S를 골랐을 때, 반드시 (S의 크기) $<=$ (S와 연결되어있는 모든 R의 크기)이다.

\item 오일러 정리 : V - E + f(면)가 일정

\item 소수 : 10 007 , 10 009 , 10 111 , 31 567 , 70 001 , 1 000 003 , 1 000 033 , 4 000 037 , 99 999 989 , 999 999 937 , 1 000 000 007 , 1 000 000 009 , 9 999 999 967 , 99 999 999 977

\item 소수 개수 : (1e5 이하 : 9592), (1e7 이하 : 664 579) , (1e9 이하 : 50 847 534) 

\item $10^{15}$ 이하의 정수 범위의 나눗셈 한번은 오차가 없다.

\item N의 약수의 개수 = $O(N^{1/3})$, N의 약수의 합 = $O(NloglogN)$

\item Euler's phi $\phi (n)=n\prod _{p\mid n}\left(1-{\frac {1}{p}}\right)$

\item $\phi(mn) = \phi(m) \phi(n) , \phi(pr^n) = pr^n - pr^{n-1} , a^{\phi(n)} \equiv 1 \pmod{n} \ \text{if coprime}$

\item Lucas' Theorem $\binom{m}{n}=\prod\binom{m_i}{n_i} \pmod p$ $m_i$, $n_i$는 $p^i$의 계수
\end{itemize}

\Algorithm
{Template}
{}
{}
{cpp}
{source/Template.cpp}
{overnap}

\Algorithm{제출하기 전 생각해볼 것}{}{}{}{}{}

\Algorithm{자주 쓰이는 문제 접근법}{}{}{}{}{}


\end{document}




