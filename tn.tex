% Team Note Sample Template
% These codes should be guaranteed, fast enough, short and easy to type.

\documentclass[landscape, 10pt, a4paper, oneside, twocolumn]{extarticle}
\usepackage{kotex}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{import}

\usepackage{teamnote}

\teamnote{Kyunghee University}{998244353}{overnap}

\ShowUsage
\ShowComplexity
\HideAuthor

\begin{document}

\maketitlepage

% Make Pagebreak if you want.
% \pagebreak 


\section{Data Structures For Range Query}

\Algorithm
{Segment Tree w/ Lazy Propagation}
{\texttt{update(1, 0, n-1, l, r, v)}}
{$\mathcal{O}(\log{N})$}
{cpp}
{source/LazyPropagation.cpp}
{overnap}

\Algorithm
{Sparse Table}
{RMQ l r: \texttt{min(lift[l][len], lift[r-(1<<len)+1][len])}}
{$\mathcal{O}(N)-\mathcal{O}(1)$}
{cpp}
{source/SparseTable.cpp}
{overnap}

\Algorithm
{Merge Sort Tree}
{}
{$\mathcal{O}(N\log{N})-\mathcal{O}(\log^2{N})$}
{cpp}
{source/MergeSortTree.cpp}
{overnap}

\Algorithm
{Binray Search In Segment Tree}
{}
{$\mathcal{O}(\log{N})$}
{cpp}
{source/BinarySearchInSeg.cpp}
{overnap}

\Algorithm
{Persistence Segment Tree}
{}
{$\mathcal{O}(\log^2{N})$}
{cpp}
{source/PersistenceSegmentTree.cpp}
{overnap}

\Algorithm
{Segment Tree Beats}
{Note the potential function}
{$\mathcal{O}(\log^2{N})$}
{cpp}
{source/SegmentTreeBeats.cpp}
{overnap}

\Algorithm
{Fenwick RMQ}
{}
{Fast $\mathcal{O}(\log{N})$}
{cpp}
{source/FenwickRMQ.cpp}
{overnap}

\section{Graph}

\Algorithm
{BipartiteMatching}
{Run dfs for all left nodes. The count of return value true equal to count of max possible matches.}
{$\mathcal{O}(VE)$}
{cpp}
{source/BipartiteMatching.cpp}
{sendol}

\Algorithm
{Max Flow}
{}
{$\mathcal{O}(VE^2)$}
{cpp}
{source/EdmondsKarp.cpp}
{overnap}

\Algorithm
{Min Cost Max Flow}
{}
{$\mathcal{O}(VEf)$}
{cpp}
{source/MCMF.cpp}
{corncheese}

\Algorithm
{Dinic's}
{}
{$\mathcal{O}(V^2E)$}
{cpp}
{source/Dinic.cpp}
{corncheese}

\Algorithm
{Strongly Connected Component}
{}
{$\mathcal{O}(N)$}
{cpp}
{source/StronglyConnectedComponent.cpp}
{overnap}

\Algorithm
{Biconnected Component}
{}
{$\mathcal{O}(N)$}
{cpp}
{source/BiconnectedComponent.cpp}
{overnap}

\Algorithm
{Lowest Common Ancestor}
{Query with the sparse table}
{$\mathcal{O}(N\log{N})-\mathcal{O}(\log{N})$}
{cpp}
{source/LowestCommonAncestor.cpp}
{overnap}

\Algorithm
{Heavy-Light Decomposition}
{Query with the ETT number and it's root node}
{$\mathcal{O}(N)-\mathcal{O}(\log{N})$}
{cpp}
{source/HeavyLightDecomposition.cpp}
{overnap}

\Algorithm
{Centroid Decomposition}
{cent[x] is the parent in centroid tree}
{$\mathcal{O}(N\log{N})$}
{cpp}
{source/CentroidDecomposition.cpp}
{overnap}


\section{Geometry}

\Algorithm
{Counter Clockwise}
{It returns $\{-1, 0, 1\}$ - the ccw of $b-a$ and $c-b$}
{$\mathcal{O}(1)$}
{cpp}
{source/CounterClockwise.cpp}
{overnap}

\Algorithm
{Line intersection}
{Check the intersection of $(x_1, x_2)$ and $(y_1, y_2)$. It requires an additional condition when they are parallel}
{$\mathcal{O}(1)$}
{cpp}
{source/LineIntersection.cpp}
{overnap}

\Algorithm
{Graham Scan}
{}
{$\mathcal{O}(N\log{N})$}
{cpp}
{source/GrahamScan.cpp}
{overnap}

\Algorithm
{Monotone Chain}
{Get the upper and lower hull of the convex hull}
{$\mathcal{O}(N\log{N})$}
{cpp}
{source/MonotoneChain.cpp}
{overnap}

\Algorithm
{Rotating Calipers}
{Get the maximum distance of the convex hull}
{$\mathcal{O}(N)$}
{cpp}
{source/RotatingCalipers.cpp}
{overnap}


\section{Fast Fourier Transform}

\Algorithm
{Fast Fourier Transform}
{FFT and multiply polynomials}
{$\mathcal{O}(N\log{N})$}
{cpp}
{source/FastFourierTransform.cpp}
{overnap}

\Algorithm
{Number Theoretic Transform}
{FFT with integer - to get better accuracy}
{$\mathcal{O}(N\log{N})$}
{cpp}
{source/NumberTheoreticTransform.cpp}
{overnap}

\Algorithm
{Fast Walsh Hadamard Transform}
{XOR convolution}
{$\mathcal{O}(N\log{N})$}
{cpp}
{source/FastWalshHadamardTransform.cpp}
{overnap}


\section{String}

\Algorithm
{Knuth-Moris-Pratt}
{}
{$\mathcal{O}(N)$}
{cpp}
{source/KnuthMorisPratt.cpp}
{overnap}

\Algorithm
{Rabin-Karp}
{The Rabin fingerprint for const-length hashing}
{$\mathcal{O}(N)$}
{cpp}
{source/RabinKarp.cpp}
{overnap}

\Algorithm
{Manacher}
{Longest radius of palindrome substring}
{$\mathcal{O}(N)$}
{cpp}
{source/Manacher.cpp}
{overnap}

\Algorithm
{Suffix Array and LCP Array}
{}
{$\mathcal{O}(N\log{N})-\mathcal{O}(N)$}
{cpp}
{source/SuffixArrayLCPArray.cpp}
{overnap}

\Algorithm
{Aho-Corasick}
{}
{$\mathcal{O}(N+\sum{M})$}
{cpp}
{source/AhoCorasick.cpp}
{overnap}


\section{Offline Query}

\Algorithm
{Mo's}
{sort by $(L\sqrt{L}, R)$}
{$\mathcal{O}(Q\log{Q}+N\sqrt{N})$}
{cpp}
{source/Mos.cpp}
{overnap}

\Algorithm
{Parallel Binary Search}
{}
{$\mathcal{O}(N\log{N})$}
{cpp}
{source/ParallelBinarySearch.cpp}
{overnap}


\section{DP Optimization}

\Algorithm
{Convex Hull Trick w/ Stack}
{\texttt{dp[i] = min(dp[j] + b[j] * a[i]), b[j] >= b[j+1]}}
{$\mathcal{O}(N\log{N})-\mathcal{O}(N)\text{ where \texttt{a[i] <= a[i+1]} }$}
{cpp}
{source/ConvexHullTrick.cpp}
{overnap}

\Algorithm
{Convex Hull Trick w/ Li-Chao Tree}
{\texttt{update(l, r, 0, \{ a, b \})}}
{$\mathcal{O}(N\log{N})$}
{cpp}
{source/LiChaoTree.cpp}
{overnap}

\Algorithm
{Divide and Conquer Optimization}
{\texttt{dp[t][i] = min(dp[t-1][j] + c[j][i]), c is Monge}}
{$\mathcal{O}(KN\log{N})$}
{cpp}
{source/DivideAndConquerOptimization.cpp}
{overnap}

\Algorithm
{Monotone Queue Optimization}
{\texttt{dp[i] = min(dp[j] + c[j][i]), c is Monge, find cross}}
{$\mathcal{O}(N\log{N})$}
{}
{}
{overnap}

\Algorithm
{Aliens Trick}
{\texttt{dp[t][i] = min(dp[t-1][j] + c[j+1][i]), c is Monge, find lambda w/ half bs}}
{$\mathcal{O}(N\log{N})$}
{}
{}
{overnap}

\Algorithm
{Knuth Optimization}
{\texttt{dp[i] = min(dp[i][k] + dp[k][j]) + c[i][j]}, Monge, Monotonic}
{$\mathcal{O}(N^2)$}
{cpp}
{source/KnuthOptimization.cpp}
{overnap}

\Algorithm
{Slope Trick}
{Use priority queue, convex condition}
{$\mathcal{O}(N\log{N})$}
{cpp}
{source/SlopeTrick.cpp}
{overnap}

\Algorithm
{Sum Over Subsets}
{\texttt{dp[mask] = sum(A[i]), i is in mask}}
{$\mathcal{O}(N2^N)$}
{cpp}
{source/SumOverSubsets.cpp}
{gina65}

\section{Number Theory}

\Algorithm
{Modular Operator}
{For Fermat's little theorem and Pollard rho}
{$\mathcal{O}(\log{N})$}
{cpp}
{source/ModularOperator.cpp}
{overnap}

\Algorithm
{Modular Inverse in $\mathcal{O}(N)$}
{Get inverse of factorial}
{$\mathcal{O}(N)-\mathcal{O}(1)$}
{cpp}
{source/ModularInverse.cpp}
{overnap}

\Algorithm
{Extended Euclidean}
{get a and b as arguments and return the solution $(x, y)$ of equation $ax + by = \gcd(a, b)$.}
{$\mathcal{O}(\log{a} + \log{b})$}
{cpp}
{source/ExtendedEuclidean.cpp}
{sendol}

\Algorithm
{Miller-Rabin}
{Fast prime test for big integers}
{$\mathcal{O}(k\log{N})$}
{cpp}
{source/MillerRabin.cpp}
{overnap}

\Algorithm
{Chinese Remainder Theorem}
{Solution for the system of linear congruence}
{$\mathcal{O}(\log{N})$}
{cpp}
{source/ChineseRemainderTheorem.cpp}
{overnap}

\Algorithm
{Pollard Rho}
{Factoring large numbers fast}
{$\mathcal{O}(N^{1/4})$}
{cpp}
{source/PollardRho.cpp}
{overnap}


\section{ETC}

\Algorithm
{Gaussian Elimination}
{}
{$\mathcal{O}(\log{N})$}
{cpp}
{source/GaussianElimination.cpp}
{overnap}

\Algorithm
{Ternary Search}
{}
{$\mathcal{O}(\log{N})$}
{cpp}
{source/TernarySearch.cpp}
{overnap}

\Algorithm
{Erasable Heap}
{}
{$\mathcal{O}(\log{N})$}
{cpp}
{source/ErasableHeap.cpp}
{overnap}

\Algorithm
{Randomized Meldable Heap}
{Min-heap \texttt{H} is declared as \texttt{Heap<T> H}. You can use \texttt{push}, \texttt{size}, \texttt{empty}, \texttt{top}, \texttt{pop} as \texttt{std::priority\_queue}. Use \texttt{H.meld(G)} to meld contents from \texttt{G} to \texttt{H}. }
{$\mathcal{O}(log n)$}
{cpp}{source/MeldableHeap.cpp}
{hyea}

\Algorithm
{Berlekamp-Massey}
{\texttt{get\_nth(\{1, 1, 2, 3, 5\}, n)}}
{}
{cpp}{source/BerlekampMassey.cpp}
{koosaga}

\Algorithm
{Splay Tree w/ Rotate}
{}
{}
{}
{}
{}

\Algorithm{Useful Stuff}{}{}{}{}{}

% ref: https://github.com/green5555/Teamnote-archive
\begin{itemize}
\item Catalan Number\\
1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012,742900\\
$C_n = binomial(n * 2, n) / (n + 1);$\\
- 길이가 2n인 올바른 괄호 수식의 수\\
- n + 1개의 리프를 가진 풀 바이너리 트리의 수\\
- n + 2각형을 n개의 삼각형으로 나누는 방법의 수
\item Burnside’s Lemma\\
경우의 수를 세는데, 특정 transform operation(회전, 반사, ..) 해서 같은 경우들은 하나로 친다. 전체 경우의 수는? 각 operation마다 이 operation을 했을 때 변하지 않는 경우의 수를 센다 (단, “아무것도 하지 않는다” 라는 operation도 있어야 함!) 전체 경우의 수를 더한 후, operation의 수로 나눈다. (답이 맞다면 항상 나누어 떨어져야 한다)
\item 알고리즘 게임\\
- Nim Game의 해법 : 각 더미의 돌의 개수를 모두 XOR했을 때 0 이 아니면 첫번째, 0 이면 두번째 플레이어가 승리.\\
- Grundy Number : 어떤 상황의 Grundy Number는, 가능한 다음 상황들의 Grundy Number를 모두 모은 다음, 그 집합에 포함 되지 않는 가장 작은 수가 현재 state의 Grundy Number가 된다. 만약 다음 state가 독립된 여러개의 state들로 나뉠 경우, 각각의 state의 Grundy Number의 XOR 합을 생각한다.\\
- Subtraction Game : 한 번에 k 개까지의 돌만 가져갈 수 있는 경우, 각 더미의 돌의 개수를 k + 1로 나눈 나머지를 XOR 합하여 판단한다.\\
- Index-k Nim : 한 번에 최대 k개의 더미를 골라 각각의 더미에서 아무렇게나 돌을 제거할 수 있을 때, 각 binary digit에 대하여 합을 k + 1로 나눈 나머지를 계산한다. 만약 이 나머지가 모든 digit에 대하여 0이라면 두번째, 하나라도 0이 아니라면 첫번째 플레이어가 승리.
\item Pick’s Theorem\\
격자점으로 구성된 simple polygon이 주어짐. I 는 polygon 내부의 격자점 수, B 는 polygon 선분 위 격자점 수, A는 polygon의 넓이라고 할 때, 다음과 같은 식이 성립한다. $A=I+B/2-1$
\item 가장 가까운 두 점 : 분할정복으로 가까운 6개의 점만 확인
\item 홀의 결혼 정리 : 이분그래프(L-R)에서, 모든 L을 매칭하는 필요충분 조건 = L에서 임의의 부분집합 S를 골랐을 때, 반드시 (S의 크기) $<=$ (S와 연결되어있는 모든 R의 크기)이다.
\item 오일러 정리 : V - E + f(면)가 일정
\item 소수 : 10 007 , 10 009 , 10 111 , 31 567 , 70 001 , 1 000 003 , 1 000 033 , 4 000 037 , 99 999 989 , 999 999 937 , 1 000 000 007 , 1 000 000 009 , 9 999 999 967 , 99 999 999 977
\item 소수 개수 : (1e5 이하 : 9592), (1e7 이하 : 664 579) , (1e9 이하 : 50 847 534) 
\item $10^{15}$ 이하의 정수 범위의 나눗셈 한번은 오차가 없다.
\item N의 약수의 개수 = $O(N^{1/3})$, N의 약수의 합 = $O(NloglogN)$
\item $\phi(mn) = \phi(m) \phi(n) , \phi(pr^n) = pr^n - pr^{n-1} , a^{\phi(n)} \equiv 1 \pmod{n} \ \text{if coprime}$
\end{itemize}

\begin{itemize}  % TODO: 점검
\item Euler's phi $\phi (n)=n\prod _{p\mid n}\left(1-{\frac {1}{p}}\right)$
\item Lucas' Theorem $\binom{m}{n}=\prod\binom{m_i}{n_i} \pmod p$ $m_i$, $n_i$는 $p^i$의 계수
\end{itemize}

\Algorithm
{Template}
{}
{}
{cpp}
{source/Template.cpp}
{overnap}

\Algorithm{제출하기 전 생각해볼 것}{}{}{}{}{}

\begin{itemize}
\item min, max 입력 테스트
\item 나눗셈이 들어가면 0과 음수 확인
\item 곱셈이 들어가면 오버플로우 확인
\item mod 필요하면 모든 중간과정과 끝 확인
\item 출력 정밀도 확인
\item FastIO
\end{itemize}

\Algorithm{자주 쓰이는 문제 접근법}{}{}{}{}{}

% ref: https://github.com/ntopia/icpc-teamnote/blob/master/teamnote.tex
% ref: 알고리즘 문제 해결 전략
\begin{itemize}
\item 비슷한 문제를 풀어본 적이 있던가?
\item 단순한 방법에서 시작할 수 있을까? (brute force)
\item 내가 문제를 푸는 과정을 수식화할 수 있을까? (예제를 직접 해결해보면서)
\item 문제를 단순화할 수 없을까?
\item 그림으로 그려볼 수 있을까?
\item 수식으로 표현할 수 있을까?
\item 문제를 분해할 수 있을까?
\item 뒤에서부터 생각해서 문제를 풀 수 있을까?
\item 순서를 강제할 수 있을까?
\item 특정 형태의 답만을 고려할 수 있을까? (정규화)
\end{itemize}

\begin{itemize}
\item 특수 조건을 꼭 활용
\item 여사건으로 생각하기
\item Convexity 파악하고 최적화
\item 게임이론 - 거울 전략 혹은 DP 연계
\item 경우 나누어 생각
\item 해법에서 역순으로
\item 딱 맞는 시간복잡도에 집착하지 말자
\end{itemize}

\begin{itemize}
    \item $N \le 8 \rightarrow N!$
    \item $10 \le N \le 20 \rightarrow 2^N$
    \item $30 \le N \le 40 \rightarrow 2^{N/2}$
    \item $N \le 50 \rightarrow N^4$
    \item $400 \le N \le 500 \rightarrow N^3$
    \item $N \le 1000 \rightarrow N^2, N^4 (\text{mitm})$
    \item $N \le 3000 \rightarrow N^2$
    \item $N \le 1e5 \rightarrow N\log{N}, N\log^2{N}$
    \item $N \ge 1e6 \rightarrow \text{sqrt 금지}$
    \item 문제에 의미있는 작은 상수 이용
    \item 최후의 수단 버킷질, 상수 커팅
\end{itemize}

\Algorithm{DP 최적화 접근}{}{}{}{}{}
\begin{itemize}
    % ref: https://arnold518.tistory.com/120
    \item 1사분면에 단조 감소하는 점들의 집합 P, 3사분면에 단조 감소하는 점들의 집합 Q에 대해, P의 점 하나와 Q의 점 하나를 이용하여 만들 수 있는 직사각형의 넓이는 Monge (ICPC WF Money For Nothing)
    \item l..r의 값들을 sum이나 min은 Monge

    \item 식 정리해서 일차함수(CHT) 혹은 비슷한 함수(MQ)를 발견, 구현 힘들면 그냥 Li-Chao
    \item Monge 성질을 보이기 어려우면 $N^2$ 나이브 짜서 opt의 단조성을 확인하고 찍맞
    \item 식이 간단하거나 변수가 독립적이면 DP 테이블을 세그 위에 올려서 해결
    \item 모든 부분 집합에 대한 DP는 SOS
    \item 침착하게 점화식부터 세우고 Monge인지 판별
\end{itemize}

\Algorithm{Monge Array}{}{}{}{}{}
\begin{itemize}
    % ref: https://justicehui.github.io/hard-algorithm/2020/04/30/monge-array/
    \item a <= b <= c <= d에서 A[a,c] + A[b,d] <= A[a,d] + A[b,c]
    \item monge array의 행 n'개, 열 m' 개를 선택한 행렬도 monge array
    \item monge array 두 개를 더해도 monge array
    \item 각 행마다 최소인 원소 중 가장 왼쪽 원소의 위치는 단조 증가
\end{itemize}

\Algorithm
{Fast I/O}
{}
{}
{cpp}{source/FastIO.cpp}
{justicehui}

\end{document}




